---
# Nginx ConfigMap for WebSocket routing
# Routes /ws/{podId}/connect to specific socket pods
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: rtc
  labels:
    app: nginx-gateway
data:
  nginx.conf: |
    worker_processes auto;
    worker_rlimit_nofile 1000000;

    events {
      worker_connections 100000;
      use epoll;
      multi_accept on;
    }

    http {
      # DNS resolver for Kubernetes - MUST use kube-dns for dynamic pod resolution
      # valid=5s ensures we pick up new pods quickly
      # ipv6=off for compatibility
      resolver kube-dns.kube-system.svc.cluster.local valid=5s ipv6=off;
      resolver_timeout 5s;

      # Timeouts optimized for millions of WebSocket connections
      keepalive_timeout 3600s;
      keepalive_requests 100000;
      send_timeout 3600s;
      client_body_timeout 3600s;
      client_header_timeout 60s;

      # Buffer settings
      client_body_buffer_size 1k;
      client_header_buffer_size 1k;
      client_max_body_size 1k;
      large_client_header_buffers 4 8k;

      # Logging - enable error log for debugging
      access_log off;
      error_log /var/log/nginx/error.log info;

      # Connection upgrade mapping
      map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
      }

      # Upstream for load-balancer (round-robin)
      upstream load_balancer {
        least_conn;
        server load-balancer-service.rtc.svc.cluster.local:8081 max_fails=3 fail_timeout=30s;
        keepalive 1000;
      }

      # Upstream for socket nodes (round-robin via ClusterIP service)
      upstream socket_nodes {
        least_conn;
        server socket-service.rtc.svc.cluster.local:8080 max_fails=3 fail_timeout=30s;
        keepalive 1000;
      }

      server {
        listen 80;
        server_name _;

        # Health check endpoint
        location /healthz {
          access_log off;
          return 200 "healthy\n";
          add_header Content-Type text/plain;
        }

        # Metrics endpoint (Nginx stub status)
        location /nginx_status {
          stub_status on;
          access_log off;
        }

        # Route to load-balancer for node resolution
        # Client calls: GET /api/v1/resolve?clientId=xxx -> LB returns { nodeId: "socket-xxx", podIp: "10.x.x.x" }
        location /api/v1/ {
          proxy_pass http://load_balancer;

          proxy_http_version 1.1;
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;

          proxy_connect_timeout 10s;
          proxy_send_timeout 30s;
          proxy_read_timeout 30s;
        }

        # Route WebSocket connections to SPECIFIC socket pod by IP address
        # Pattern: /ws/ip/{podIp}/connect?clientId=xxx -> http://{podIp}:8080/ws/connect?clientId=xxx
        # The podIp is obtained from /api/v1/resolve response
        # Example: /ws/ip/10.244.0.46/connect?clientId=user123 -> http://10.244.0.46:8080/ws/connect?clientId=user123
        location ~ ^/ws/ip/(?<podip>[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/connect$ {
          # Proxy directly to pod IP - bypasses DNS entirely
          # $is_args$args preserves the query string (e.g., ?clientId=xxx)
          proxy_pass http://$podip:8080/ws/connect$is_args$args;

          # WebSocket upgrade headers
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection $connection_upgrade;

          # Standard proxy headers
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
          proxy_set_header X-Socket-Node $podip;

          # WebSocket timeouts (keep connection alive)
          proxy_connect_timeout 10s;
          proxy_send_timeout 3600s;
          proxy_read_timeout 3600s;

          # Buffering disabled for WebSocket
          proxy_buffering off;
        }

        # Fallback: /ws/connect without node ID -> round-robin to any socket
        location = /ws/connect {
          proxy_pass http://socket_nodes;

          # WebSocket upgrade headers
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection $connection_upgrade;

          # Standard proxy headers
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;

          # WebSocket timeouts (keep connection alive)
          proxy_connect_timeout 10s;
          proxy_send_timeout 3600s;
          proxy_read_timeout 3600s;

          # Buffering disabled for WebSocket
          proxy_buffering off;
        }

        # Fallback for unmatched routes
        location / {
          return 404 "Not found\n";
        }
      }
    }

---
# Nginx Deployment with HPA
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-gateway
  namespace: rtc
  labels:
    app: nginx-gateway
    app.kubernetes.io/name: nginx-gateway
    app.kubernetes.io/part-of: reactive-rtc
spec:
  replicas: 1  # Start with 1 for local dev, HPA will scale
  selector:
    matchLabels:
      app: nginx-gateway
  template:
    metadata:
      labels:
        app: nginx-gateway
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9113"
        prometheus.io/path: "/metrics"
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app: nginx-gateway
                topologyKey: kubernetes.io/hostname
      containers:
        - name: nginx
          image: nginx:1.25-alpine
          ports:
            - containerPort: 80
              name: http
              protocol: TCP
          volumeMounts:
            - name: nginx-config
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
          resources:
            requests:
              cpu: 500m
              memory: 512Mi
            limits:
              cpu: 1000m
              memory: 1024Mi
          livenessProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 5

        # Nginx Prometheus Exporter sidecar
        - name: nginx-exporter
          image: nginx/nginx-prometheus-exporter:0.11
          args:
            - "-nginx.scrape-uri=http://localhost:80/nginx_status"
          ports:
            - containerPort: 9113
              name: metrics
              protocol: TCP
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 100m
              memory: 128Mi

      volumes:
        - name: nginx-config
          configMap:
            name: nginx-config

---
# Nginx Service (LoadBalancer type for external access)
apiVersion: v1
kind: Service
metadata:
  name: nginx-gateway-service
  namespace: rtc
  labels:
    app: nginx-gateway
  annotations:
    # For cloud providers, configure load balancer settings
    # AWS:
    # service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    # service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    # GCP:
    # cloud.google.com/load-balancer-type: "Internal"
spec:
  type: LoadBalancer
  selector:
    app: nginx-gateway
  ports:
    - name: http
      port: 80
      targetPort: 80
      protocol: TCP
  sessionAffinity: None

---
# HPA for Nginx Gateway
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx-gateway-hpa
  namespace: rtc
  labels:
    app: nginx-gateway
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx-gateway
  minReplicas: 1
  maxReplicas: 3
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 30
        - type: Pods
          value: 2
          periodSeconds: 30
      selectPolicy: Max
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 75

---
# PodDisruptionBudget for Nginx
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nginx-gateway-pdb
  namespace: rtc
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: nginx-gateway

